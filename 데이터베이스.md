# 데이터베이스 (20 문항)

### 데이터베이스 설계

#### 데이터베이스 설계 개념

사용자의 요구 분석해 그것들을 데이터베이스의 구조에 맞게 변형한 후 특정 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것

- 설계 순서 

  요구 조건 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 구현

#### 데이터베이스 설계 시 고려사항

- **무결성** : 삽입, 삭제, 갱신 등의 연산 후에도 DB에 저장된 데이터가 정해진 제약 조건을 항상 만족
- **일관성** : DB에 저장된 데이터들 사이나, 특정 질으ㅔ에 대한 응답이 처음부터 끝까지 변함 없이 일정
- **회복** : 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구
- **보안** : 데이터 노출, 변경, 손실로부터 보호
- **효율성** : 응답시간 단축, 시스템의 생산성, 저장 공간의 최적화 
- **데이터베이스 확장** : 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가

#### 요구 조건 분석

DB를 사용할 사람들로부터 필요한 용도를 파악하는 것

- 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집
- 수집된 정보를 바탕으로 요구 조건 명세를 작성

#### 개념적 설계 (정보 모델링, 개념화)

정보의 구조를 얻기 위해 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정

- 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
- 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성
- DBMS에 독립적인 개념 스키마 설계

#### 논리적 설계 (데이터 모델링)

현실 세계의 자료를 컴퓨터가 이해할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정

- 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화
- 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
- 트랜잭션의 인터페이스를 설계
- 관계형 DB라면 테이블을 설계하는 단계

#### 물리적 설계 (데이터 구조화)

논리적 구조로 표현된 데이터를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정

- 다양한 DB응용에 대해 처리 성능을 얻기 위해 DB 파일의 저장 구조 및 액세스 경로 결정
- 컴퓨터에 저장되는 방법 묘사

#### 데이터베이스 구현

논리적 설계와 물리적 설계 단계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정



### 데이터 모델의 개념

#### 데이터 모델 정의

현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형

- 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들의 모임
- 현실 세계를 DB에 표현하는 중간 과정, DB 설계 과정에서 데이터의 구조를 논리적으로 표현하기 위해 사용되는 지능적 도구
- **DB 모델의 구성 요소** : 개체, 속성, 관계
- **DB 모델의 종류** : 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
- **DB 모델에 표시할 요소** : 구조, 연산, 제약 조건

#### 데이터 모델의 구성 요소

**개체**

DB에 표현하려는 것, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체

- 유일한 식별자에 의해 식별 가능

**속성**

데이터의 가장 논리적인 단위, 파일 구조상의 데이터 항목 또는 데이터 필드에 해당

- 속성의 수를 디그리 또는 차수라고 함
- 개체를 구성하는 항목
- 속성의 특성에 따른 분류 : 기본 속성, 설계 속성, 파생 속성
- 개체 구성 방식에 따른 분류 : 기본키 속성, 외래키 속성, 일반 속성

**관계**

개체 간의 관계 또는 속성 간의 논리적인 연결

- 관계의 형태 : 일 대 일, 일 대 다, 다 대 다
- 관계의 종류 : 종속 관계, 중복 관계, 재귀 관계, 배타 관계 

#### 개념적 데이터 모델

현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정

- 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용해 현실 세계를 표현
- = 정보 모델
- E-R 모델

#### 논리적 데이터 모델

개념적 모델링 과정에서 얻는 개념적 구조를 컴퓨터가 이해하고 처리할 수 있도록 변환하는 과정

- DBMS는 특정 논리적 데이터 모델 하나만 선정해 사용함

#### 식별자의 정의 및 분류

식별자는 하나의 개체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자, 모든 개체는 한 개 이상의 식별자를 반드시 가짐

| 분류             | 식별자                   |
| ---------------- | ------------------------ |
| 대표성 여부      | 주 식별자, 보조 식별자   |
| 스스로 생성 여부 | 내부 식별자, 외부 식별자 |
| 단일 속성 여부   | 단일 식별자, 복합 식별자 |
| 대체 여부        | 원조 식별자, 대리 식별자 |

#### 관계형 데이터 모델

가장 널리 사용되는 데이터 모델, 2차원적인 표를 이용해 데이터 상호 관계를 정의하는 DB 구조



### 관계형 데이터베이스의 구조

#### 관계형 데이터베이스 개요

- 개체나 관계를 모두 릴레이션이라는 표로 표현
- 릴레이션은 개체를 표현하는 개체 릴레이션, 관계를 나타내난 관계 릴레이션으로 구분
- 장점 : 간결, 다른 DB로의 변환 용이
- 단점 : 성능이 떨어짐

#### 관계형 데이터베이스의 Relation 구조

릴레이션은 데이터들을 표 형태로 표현한 것으로 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성

![](http://www.databaser.net/moniwiki/pds/_ea_b4_80_ea_b3_84_ed_98_95_eb_8d_b0_ec_9d_b4_ed_84_b0_eb_aa_a8_eb_8d_b8/r_model02.png)

**튜플 (=레코드)**

- 릴레이션을 구성하는 각각의 행
- 속성의 모임으로 구성
- 튜플의 수 : 카디널리티, 기수, 대응수

**속성 (=데이터 필드)**

- DB를 구성하는 가장 작은 논리적 단위
- 개체의 특성 기술
- 속성의 수 : 디그리, 차수

**도메인**

- 하나의 속성이 취할 수 있는 같은 타입의 원자값들의 집합
- ex : 성별 속성의 도메인은 여, 남

**릴레이션 특징**

- 릴레이션에 포함된 튜플은 모두 상이함
- 튜플 사이에 순서 없음
- 속성의 순서 중요하지 않음
- 속성은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장함



### 관계형 데이터베이스의 제약조건 - 키

#### 제약 조건

DB에 저장되는 데이터의 정확성을 보장하기 위해 키를 이용해 입력되는 데이터에 제한을 주는것으로 개체 무결성 제약, 참조 무결성 제약 등이 해당된다.

#### 키의 개념 및 종류

키는 DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 속성을 말함

- 종류 : 후보키, 기본키, 대체키, 슈퍼키, 외래키

##### 키

릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 기본키로 사용할 수 있는 속성들

- 모든 릴레이션에는 반드시 하나 이상의 후보키 존재
- 유일성 : 하나의 키 값으로 하나의 튜플만을 유일하게 식별
- 최소성 : 모든 레코드들을 유일하게 식별하는 데 꼭 필요한 속성으로만 구성

##### 기본키

후보키 중에서 특별히 선정된 주키, 중복 불가

- 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
- 유일성과 최소성을 가짐
- NULL 값 가질 수 없음

##### 대체키 (=보조키)

후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다

##### 슈퍼키

한 릴레이션 내에 있는 속성들의 집합으로 구성된 키

- 유일성은 만족시키지만 최소성은 만족시키지 못함

##### 외래키

다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

- 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간의 참조 관계를 표현하는데 중요한 도구
- 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없음



### 관계형 데이터베이스의 제약조건 - 무결성

#### 무결성의 개념 및 종류

무결성이란 DB에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미

- 무결성 제약 조건 : DB에 들어 있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 DB 내에 저장되는 것을 방지하기 위한 제약 조건
- 종류 : 개체 무결성, 도메인 무결성, 참조 무결성

##### 개체 무결성

기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정

##### 도메인 무결성

주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정

##### 참조 무결성

외래키 값은 Null이나 참조 릴레이션의 기본키 값과 동일해야한다. 참조할 수 없는 외래키 값을 가질 수 없다는 규정

- 외래키와 참조하려는 테이블의 기본키는 도메인과 속성 개수가 같음

##### 사용자 정의 무결성

속성 값들이 사용자가 정의한 제약 조건에 만족해야한다는 규정

#### 데이터 무결성 강화

- 데이터 무결성은 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적잘한 무결성을 정의하고 강화해야함
- 애플리케이션, 데이터베이스 트리거, 제약 조건을 이용해 강화할 수 있음

##### 애플리케이션

- 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가
- DB에서는 데이터 무결성 제약을 정의할 수 없으므로 복잡한 규칙 등은 애플리케이션 내에서 처리
- 장점 : 사용자 정의 같은 복잡한 무결성 조건의 구현이 가능
- 단점 : 소스 코드에 분산되어 있어 관리가 힘듦, 개별적인 시행으로 인해 적정성 검토가 힘듦

##### 데이터베이스 트리거

- 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가
- 장점 : 통합 관리가 가능, 복잡한 요구 조건의 구현이 가능
- 단점 : 운영 중 변경이 어려움, 사용상 주의가 필요함

##### 제약 조건

- DB에 제약 조건을 설정해 무결성을 유지
- 장점 : 통합 관리 가능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생 방지
- 단점 : 복잡한 제약 조건의 구현과 예외적인 처리 불가능



### 관계대수

#### 관계대수 개요

관계형 DB에서 원하는 정보를 검색하기 위해 어떻게 유도하는가를 기술한 절차적인 언어

- 릴레이션 연산의 결과는 릴레이션

- 순수 관계 연산자 : Select, Project, Join, Division
- 일반 집합 연산자 : UNION, INTERSECTION, DIFFERENCE, CARTESIAN PRODUCT

##### Select

조건을 만족하는 튜플을 부분집합

- 행에 해당하는 튜플을 구하는 것으로 수평 연산이라고도 함
- 표기형식 : σ<조건>(R)

##### Project 

주어진 릴레이션에서 속서 리스트에 제시된 속성 값만을 추출

- 열에 해당하는 속성을 추출하는 것으로 수직연산자라고도 함
- 표기형식 : π<속성리스트>(R)

##### Join

공통 속성을 중심으로 두개의 릴레이션을 하나로 합치는 연산

- Join의 결과로 만들어진 릴레이션의 차수는 두 릴레이션의 차수를 합한 것과 같다
- Cartesian Product를 수행한 다음 Select를 수행한 것과 같다
- 표기 형식 : R ⋈키속성r=키속성s S

##### Division

R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구한는 연산

- 표기 형식 : R [속성r / 속성s] S



### 정규화

#### 정규화의 개요

정규화란 함수적 종속성 등 종석성 이론을 이용해 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정

- 정규형의 차수가 높아질수록 만족시켜야할 제약조건이 늘어남
- 논리적 설계 단계에서 수행
- 논리적 처리 및 품질에 큰 영항을 미침
- 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장
- 장점 : 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 데이터의 정확성이 높아짐
- 단점 : 물리적 접근이 복잡하고 너무 많은 조인으로 인해 조회 성능이 저하됨

#### 정규화의 목적

- 데이터 구조의 안정성 및 무결성 유지
- 효과적인 검색 알고리즘 생성
- 데이터 중복 배제하여 이상의 발생 방지 및 자료 저장 공간의 최소화 가능
- 데이터 삽입 시 릴레이션 재구성할 필요성 줄임
- 데이터 모형의 단순화가 가능

#### 이상의 개념 및 종류

##### 이상

정규화를 거치지 않으면 DB 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란한 현상이 발생

##### 종류

- 삽입 이상 : 데이터 삽입 시 원하지 않는 값들도 함께 삽입되는 현상
- 삭제 이상 : 의도와는 상관 없는 값들도 함께 삭제되는 연쇄가 일어나는 현상
- 갱신 이상 : 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상

#### 정규화 과정

##### 1NF

릴레이션에 속한 모든 도메인이 원자값만으로 구성되어 있는 정규형

##### 2NF

1NF 만족, 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수 종속을 만족하는 정규형

##### 3NF

2NF 만족, 이행적 종속을 만족하지 않는 정규형

##### BCNF

결정자가 모두 후보키인 정규형

##### 4NF

다치종속이 성립하는 정규형



#### 반정규화

시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정

- 장점 : 시스템의 성능이 향상되고 관리 효율성 증가
- 단점 : 데이터의 일관성 및 정합성 저하



#### 트랜잭션

##### 정의

DB의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위, 한꺼번에 모두 수행되어야 할 일련의 연산

##### 특성

데이터의 무결성을 보장하기 위해 DBMS의 트랜잭션이 가져야할 특성

- 원자성 : 연산은 모두 완료되든지 전혀 반영되지 않도록 복구 되어야한다
- 일관성 : 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후의 상태가 같아야한다.
- 독립성 : 둘 이상의 트랜잭션이 동시에 실행되는 경우 하나가 완료될 때까지 기다린다.
- 영속성 : 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다.



#### 인덱스

데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조

- 파일 레코드에 빠르게 엑세스 가능
- 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적
- 인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 확인하는 TABLE SCAN이 발생

##### 인덱스 설계 시 고려사항

- 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있음
- 인덱스를 지나치게 많이 만들면 오버헤드가 발생함
- 넓은 범위를 인덱스로 처리하면 많은 오버헤드가 발생
- 인덱스를 만들면 추가적인 저장 공간이 필요
- 인덱스와 테이블 데이터 저장 공간이 분리되도록 설계



#### 뷰

##### 개요

사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 이름을 가지는 가상 테이블

- 물리적으로 존재하지 않음
- 임시적인 작업을 위한 용도로 활용
- 조인문의 사용 최소화로 사용상의 편의성을 최대화

##### 장점

- 논리적 데이터 독립성 제공

- 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원

- 사용자의 데이터 관리를 간단하게 해줌

- 접근 제어를 통한 자동 보안 제공

##### 단점

- 독립적인 인덱스를 갖지 못함
- 뷰의 정의 변경 불가
- 삽입, 삭제, 갱신 연산에 제약이 따름



#### 클러스터

##### 개요

데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법

- 데이터의 분포도가 넓을수록 유리

##### 장점

- 데이터 조회 속도 향상
- 클러스터링키 열을 공유하므로 저장 공간이 줄어듦

##### 단점

- 데이터 입력, 수정, 삭제에 대한 성능 저하
- 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생 (TABLE SCAN)



#### 데이터베이스 보안 / 암호화

##### 데이터베이스 보안 개요

DB의 일부분 또는 전체에 대해 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술

##### 암호화

데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것

##### 개인키 암호 방식 = 비밀키 암호 방식

동일한 키로 데이터를 암호화, 복호화

- =대칭 암호 방식=단일키 암호화 기법
- 비밀키는 제3자에게 노출시키지 않고 DB 사용 권한이 있는 사용자만 나누어 가짐
- 종류 : 전위 기법, 대체 기법, 대수 기법, 합성 기법 (DES, LUCIFER)

##### 공개키 암호 방식

서로 다른 키로 암호화, 복호화

- 데이터를 암호화할 때 사용하는 키(공개키)는 DB 사용자에게 공개, 복호화할 때 사용하는 키(비밀키)는 관리자가 비밀리에 관리
- =비대칭 암호 방식
- 종류 : RSA



### SQL

#### DDL (데이터 정의어)

SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의, 변경, 삭제할 때 사용하는 언어

- 논리적 데이터 구조와 물리적 데이터 구조의 사상 정의
- DB 관리자나 설계자가 사용
- 종류 : CREATE, ALTER, DROP



#### DML (데이터 조작어)

DB 사용자가 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 처리하는데 사용되는 언어

- DB 사용자와 DBMS 간의 인터페이스 제공
- 종류 : SELECT, INSERT, DELETE, UPDATE, JOIN

##### JOIN

![JOIN](https://i.stack.imgur.com/hMKKt.jpg)

- **INNER JOIN**

  조건이 없는 INNER JOIN는 CROSS JOIN과 결과 같음

  - EQUI JOIN
    - JOIN 대상 테이블에서 공통 속성을 기준으로 '=' 비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성
    - 같은 속성을 한번만 표기하는 방법 : NATURAL JOIN
  - NON-EQUI JOIN
    - JOIN 조건에 '=' 조건이 아닌 나머지 비교 연산자 사용 (>,<,<>,>=,<=)

- **OUTER JOIN**

  JOIN 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 방법

  - LEFT OUTER JOIN
    - INNER JOIN의 결과 + 우측 항 릴레이션의 튜플과도 맞지 않는 우측 항의 튜플에 NULL 값 넣음
  - RIGHT OUTER JOIN
    - INNER JOIN의 결과 + 좌측 항 릴레이션의 튜플과도 맞지 않는 좌측 항의 튜플에 NULL 값 넣음
  - FULL OUTER JOIN
    - LEFT OUTER JOIN + RIGHT OUTER JOIN

- **SELF JOIN**

  같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN

#### DCL (데이터 제어어)

데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는 데 사용되는 언어

- DBA가 데이터 관리 목적으로 사용
- 종류 : COMMIT, ROLLBACK, GRANT, REVOKE



