# 프로그래밍 언어

### 자바의 특징

#### 객체 지향

자바는 객체지향 언어로서 클래스 계층 구조, 상속성, 다형성, 캡슐화 등을 지원

#### 멀티스레드

하나의 프로그램에서 다수의 스레드가 동시에 실행할 수 있는 환경을 지원

#### 플랫폼 독립성

하드웨어, 운영체제 등 플랫폼에 종속되지 않는 독립적인 바이트 코드로 컴파일 되며 자바 가상 기계만 있으면 실행 가능



### 자바의 데이터 타입

#### 기본 타입

- boolean : 1byte
- char : 2byte
- byte : 1byte
- short : 2byte
- int : 4byte
- long : 8byte
- float : 4byte
- double : 8byte

#### 레퍼런스 타입

##### 용도

- 배열에 대한 레퍼런스
- 클래스에 대한 레퍼런스
- 인터페이스에 대한 레퍼런스



### 자바의 예외 처리

![](https://t1.daumcdn.net/cfile/tistory/2775144B54D9DA7132?download)



### 객체 지향 언어의 특성

#### 캡슐화

클래스라는 캡슐을 사용해 객체를 표현하며 메소스와 필드를 클래스 내에 구현함

- 목적 : 객체 내 데이터에 대한 보안, 보호, 외부 접근 제한 => 정보 은닉

#### 상속

상위 개체의 속성이 하위 개체에 물려져, 하위 개체가 상위 개체의 속성을 모두 갖음

- 부모(슈퍼) 클래스 - 자식(서브) 클래스
- 코드의 중복 작성을 방지해 코드의 재사용이 가능

#### 다형성

같은 이름의 메소드 호출에 대해 객체에 따라 다른 동작을 할 수 있도록 구현되는 것

- 오버라이딩



#### 메소드 오버로딩

한 클래스 내에 이름이 같지만 인자의 타입이나 개수가 소로 다른 여러 개의 메소드 중복

- 메소드 이름 동일
- 인자의 개수 다르거나, 타입이 다름
- 리턴 타입 동일
- 접근 지정자 상관 없음



### 가비지와 가비지 컬렉션

#### 가비지

응용프로그램에서 더 이상 사용되지 않는 메모리

#### 가비지 컬렉션

가비지는 더 이상 참조되지 않기 떄문에 가비지가 차지하고 있는 메모리 공간은 회수되어야한다.

- JVM은 가용 공간이 일정 크기 이하로 줄어들게 되면 자동으로 가비지를 회수하여 가용 메모리 공간을 늘린다 => 가비지 컬렉션
- 가비지 컬렉터 : 가비지 컬렉션을 수행하는 주체

규모가 큰 프로그램 개발에 자바는 적합하지 않음

#### 가비지 컬렉션 강제 수행

```java
System.gc(); // 가비지 컬렉션 작동 요청
```

- 호출한 즉시 가비지 컬렉터가 작동하는 것 아님
- JVM이 전적으로 판단하여 적절한 시점에 작동



### 접근 지정자

객체를 캡슐화하기 때문에 객체에 다른 객체가 접근하는 것을 허용할 것인지 말지를 지정할 때 필요

#### 클래스 접근 지정자

다른 클래스에서 이 클래스 이름을 사용할 수 있는지 허용 여부를 지정하는 것

##### public

어떤 다른 클래스에서도 사용할 수 있음

##### default (생략)

같은 패키지 내에 있는 클래스들만의 접근이 허용됨

#### 멤버 접근 지정자

클래스 멤버에 대한 접근 지정

##### public

모든 클래스에서 접근 가능

##### private

비공개, 모든 클래스에서 접근 불가

##### protected

보호된 공개, 같은 패키지 내의 모든 클래스 또는 이 클래스를 상속 받은 자식의 경우 접근 가능

##### dafault

같은 패키지 내의 모든 클래스 접근 가능



### non-static 멤버와 static 멤버의 차이

|             | non-static 멤버                                              | static 멤버                                                  |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 시간적 특성 | 멤버는 객체마다 별도 존재<br />- 인스턴스 멤버               | 멤버는 클래스 당 하나 생성<br />- 객체 내부가 아닌 별도 공간에 생성<br />- 클래스 멤버 |
| 공간적 특성 | 객체 생성 시 멤버 생성<br />- 객체가 생길 때 멤버 생성<br />- 객체 사라지면 멤버도 사라짐 | 클래스 로딩 시 멤버 생성<br />- 객체가 생기기 전에 생성<br />- 객체 사라져도 존재, 프로그램 종료 시 사라짐 |
| 공유의 특성 | 공유되지 않음                                                | 클래스의 모든 객체들에 의해 공유됨                           |

##### static 멤버

- 객체를 생성하지 않고도 사용할 수 있는 멤버
- 클래스 당 하나만 생성되는 멤버, 동일한 클래스의 모든 객체들이 공유
- 어떤 객체도 생성되기 전 프로그램을 시작할 때 생성
- =클래스 멤버

##### non-static 멤버

- 객체가 생길 때 객체 내부에 하나씩 생성
- 객체마다 자신의 고유한 멤버 공간을 가지며 공유하지 않음
- 객체가 사라지면 멤버도 같이 사라짐
- = 인스턴스 멤버

##### 

#### static 메소드 제약 조건

- static 메소드는 오직 static 멤버만 접근 가능
- static 메소드에서는 this 키워드 사용 불가



### final

##### final 클래스

클래스를 상속 받을 수 없음을 지정

##### final 메소드

메소드가 더 이상 오버라이딩할 수 없음을 지정

##### final 필드, 상수 정의

상수를 정의할 떄 사용하는 방법

- 선언 시 초기값 지정
- 한 번 정의되면 값을 변경할 수 없음

### 

### 객체 타입 변환 : 업캐스팅과 다운캐스팅

#### 업캐스팅

서브 클래스 객체가 슈퍼 클래스 타입으로 변환되는 것

- 명시적으로 타입 변환을 하지 않아도 됨

#### 다운캐스팅

업캐스팅된 것을 다시 원래대로 되돌리는 것

- 명시적으로 타입을 지정해야 함



### 메소드 오버라이딩

#### 정의

슈퍼 클래스와 서브 클래스의 메소드 사이에 발생하는 관계, 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스에서 재작성하는 것

- 메소드 이름, 리턴 타입, 매개 변수 리스트 모두 같아야 함
- 재정의 되면 슈퍼클래스의 메소드 무시됨 (동적 바인딩)
  - 동적 바인딩은 실행할 메소드를 실행 시 결정 (컴파일 시 아님)
  - super 키워드를 이용하면 슈퍼 클래스의 멤버에 접근 가능

#### 제약 조건

- 슈퍼 클래스 메소드와 완전히 동일한 메소드를 재정의

- 슈퍼 클래스 메소드의 접근 지정자보다 접근 범위가 좁아질 수 없음

  (public > protected > default > private)



### 오버로딩과 오버라이딩

| 비교 요소 | 메소드 오버로딩                                              | 메소드 오버라이딩                                            |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 정의      | 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 작성   | 서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 작성 |
| 관계      | 동일한 클래스 내 혹은 상속 관계                              | 상속 관계                                                    |
| 목적      | 이름이 같은 여러 개의 메소드를 중복 정의하여 사용의 편리성 향상 (다형성) | 슈퍼 클래스에서 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의 하고자 함 |
| 조건      | 메소드 이름, 리턴 타입 동일, 안자의 개수나 인자의 타입이 다름 | 메소드 이름, 인자의 타입, 인자의 개수, 인자의 리턴 타입 등 모두 같음 |
| 바인딩    | 정적 바인딩<br />- 컴파일 시 중복된 메소드 중 호출되는 메소드 결정 | 동적 바인딩<br />- 실행 시간에 오버라이딩된 메소드를 찾아 호출 |



### 인터페이스와 추상 클래스

| 비교        | 내용                                                         |
| ----------- | ------------------------------------------------------------ |
| 추상 클래스 | - 일반 메소드 포함 가능<br />- 상수, 변수 필드 포함 가능<br />- 모든 서브 클래스에 공통된 메소드가 있는 경우에 적합 |
| 인터페이스  | - 모든 메소드가 추상 메소드<br />- 상수 필드만 포함 가능<br />- 다중 상속 지원 |

- 객체 생성 불가



### 박싱과 언박싱

#### 박싱

기본 데이터 타입을 Wrapper 클래스로 변환하는 것

#### 언박싱

Wrapper 클래스를 기본 데이터 타입으로 변환하는 것



### 제네릭과 컬렉션

#### 컬렉션 개념

- 고정 크기의 배열이 가지는 단점을 극복하고 가볌 개수의 객체들을 쉽게 삽입하고, 삭제와 검색을 할 수 있는 가변 크기의 컨테이너

- 요소라고 불리는 가변 개수의 객체들의 저장소
- 요소들을 관리하기 위해 요소의 추가, 삭제,  검색 등의 기능 제공

#### 컬렉션 특징

- 제네릭이라는 기법으로 구현
- 컬렉션의 요소는 객체들만 가능



### 스레드와 멀티태스킹

#### 멀티태스킹이란?

멀티+태스킹의 합성어로 다수의 작업을 동시에 처리하는 것

#### 스레드와 멀티스레딩

##### 스레드

thread of control의 준말로 프로그램 코드를 이동하면서 실행하는 하나의 제어

- 하나의 스레드에서는 하나의 작업만 처리
- 스레드는 실행 단위

> main()이 시작되면 main() 메소드를 실행하는 하나의 스레드 A 생성, A는 main() 함수에서 호출하는 다른 객체의 메소드 실행하고 여기서 또 다른 메소드가 호출되면 그 메소드 코드 실행
>
> 중간에 새로운 스레드 B가 생기면 B는 자신이 탄생한 코드에서부터 독립적으로 실행을 진행

##### 멀티 프로세싱

하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 기법

- 각 프로세스는 고유한 메모리 영역 보유하고 독립적으로 실행
- 상호 통신의 오버헤드가 크고 문맥 교환에 따른 과도한 시간 소모

##### 멀티 스레딩

하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 기법

- 모든 스레드가 응용프로그램 내의 자원과 메모리 공유=> 통신에 따른 오버헤드 적음, 문맥 교환 시간 짧음
- 응용프로그램이 다수의 스레드를 가지고 다수의 작업을 동시에 처리함 => 여러 개의 작업을 순차적으로 진행하는 경우 발생하는 시간 지연과 자원의 비효율적인 사용 개선

#### 자바 스레드와 JVM

자바에는 프로세스 개념이 존재하지 않고 스레드 개념만 존재, JVM이 멀티스레딩 지원

- 자바 스레드 : JVM에 의해 스케쥴되는 실행 단위 코드 블록
- 스레드 스케줄링은 JVM에 의해 이루어짐
- 스레드가 생성되면 스레드에 관련된 정보(TCB) 생성, 종료되면 TCB 사라짐

#### 데몬 스레드와 일반 스레드

##### 데몬 스레드

JVM이 스스로 필요에 의해 사용하는 스레드

- 가비지 컬렉션 스레드
- 응용프로그램에서 작성한 스레드를 데몬 스레드로 표시하여 JVM이 데몬 스레드로 인식하게 할 수 있음

##### 일반 스레드

응용프로그램에서 생성한 스레드

- main() 메소드



#### 스레드 생명 주기와 스케줄링

##### 스레드 상태

스레드는 생명 주기를 가짐

![스레드 생명주기](https://image3.slideserve.com/6292240/slide22-l.jpg)

##### 스레드 우선순위와 스케줄링

JVM은 우선순위 기반으로 스레드를 스케줄링함



