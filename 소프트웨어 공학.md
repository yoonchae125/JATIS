# 소프트웨어 공학 (10 문항)

## 요구사항 확인

### 소프트웨어 생명주기

#### 소프트웨어 생명주기

소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것

- 소프트웨어 생명 주기를 표현하는 형태의 소프트웨어 생명 주기 모형이라고 한다.
- 문제의 유형, 개발 방법 등에 따라 특정 모형 선택

#### 폭포수 모형

- 소프트웨어 개발 시 이전 단계로 돌아 갈 수 없음
- 전통적, 고전적 생명 주기 모형
- 소프트웨어 개발 과정의 한 단계가 끝나야만 다음 단계로 넘어갈 수 있는 선형 순차적 모형
- 메뉴얼 작성
- 두 개 이상의 과정 병행 x

#### 프로토타입 모형 (=원형 모형)

- 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어의 견보품을 만들어 최종 결과물 예측
- 소프트웨어 개발이 완료된 시점에서 오류가 발견되는 폭포수 모델의 단점 보안하기 위한 모형

#### 나선형 모형 (=점진적 모형)

- 보헴이 제안
- 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 함
- 점진적으로 개발 과정이 반복되어 누락되거나 추가된 요구사함 첨가 가능, 유지 보수 필요 없음

#### 애자일 모형

- 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기(이터레이션, 스프린트)를 반복하면서 개발 과정 진행
- 고객과의 소통에 초점을 맞춘 방법론
- 짧은(주단위) 개발 주기(이터레이션, 스프린트)를 반복, 주기마다 만들어지는 결과물에 대한 고객의 평가와 요구 적극 수용
- 요구사항에 우선순위 부여

**폭포수 모형 vs 애자일 모형**

| 구분                        | 폭포수 모형                 | 애자일 모형                             |
| --------------------------- | --------------------------- | --------------------------------------- |
| 새로운 고객의 요구사항 반영 | 어려움                      | 지속적으로 반영                         |
| 고객과의 의사소통           | 적음                        | 지속적임                                |
| 테스트                      | 마지막에 모든 기능을 테스트 | 반복되는 일정 주기가 끝날 때마다 테스트 |
| 개발 중심                   | 계획, 문서(메뉴얼)          | 고객                                    |



### 스크럼 기법

#### 스크럼 개요

- 팀이 중심이 되어 개발의 효율성을 높인다는 의미가 내포됨

- 팀원 스스로가 스크럼 팀을 구성, 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 함

- 제품 책임자, 스크럼 마스터, 개발팀으로 구성

  **제품 책임자**

  - 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사 결정할 사람들
  - 개발 의뢰자, 사용자
  - 이해관계자들의 의견을 종합해 제품에 대한 요구사항을 작성하는 주체
  - 요구사항이 담긴 백로그 작성, 백로그 우선순위 지정

  **스크럼 마스터**

  - 팀원들이 스크럼을 잘 수행할 수 있도록 객관적인 시각에서 조언 해주는 가이드 역할
  - 회의 주관, 진행 사항 점검, 개발 과정에서 발생된 장애 요소 공론화하여 처리

  **개발팀**

  - 제품 책임자, 스크럼 마스터 이외의 팀원
  - 7~8명

#### 스크럼 개발 프로세스

![스크럼개발프로세스](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F214EE04E58A2A65C155D51)

**제품 백로그**

- 제품 개발에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록
- 새롭게 도출되는 요구사항 지속적으로 업데이트
- 제품 백로그에 작성된 사용자 스토리 기반으로 릴리즈 계획(전체 계획 일정) 수립

**스프린트 계획 회의**

- 제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 것
- 스프린트에서 처리할 요구사항을 태스크라는 작업단위로 분할해 개발자별로 수행할 작업 목록인 스프린트 백로그에 작성

**스프린트**

- 실제 개발 작업을 진행하는 과정, 2~4주 내

- 태스크 상태 - 할 일(To Do), 진행 중(In Progress), 완료(Done)

**일일 스크럼 회의**

- 모든 팀원이 매일 15분 정도 진행 상황 점검
- 남은 작업은 소멸 차트에 표시
- 스크럼 마스터는 발견된 장애요소를 해결할 수 있도록 도와줌

**스프린트 검토 회의**

- 분분 또는 전체 완성 제품이 요구사항에 잘 부합되는지 사용자가 포함된 참석자 앞에서 테스팅
- 제품 책임자는 개선할 사항에 대한 피트백 정리 후 제품 백로그 업데이트

**스프린트 회고**

- 스프린트 주기를 되돌아 보며 규칙 잘 준수했는지, 개선할 점은 없는지 확인하고 기록



### XP(eXtreme Programming) 기법

#### XP(eXtreme Programming)

수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복 극대화해 개발 생산성을 향상시키는 방법

- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 빠르게 개발하는 것이 목적
- 소규모 인원의 프로젝트에 효과적
- 5가지 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백

#### XP 개발 프로세스

![image-20200109213618443](http://www.skby.net/blog/wp-content/uploads/2018/11/1-73.png)

**사용자 스토리**

- 고객의 요구사항을 작은 시나리오로 표현
- 내용은 기능 단위로 구성, 필요한 경우 테스트 케이스 기재

**릴리즈 계획 수립**

- 부분 혹은 전체 개발 완료 시점에 대한 일정 수립

**스파이크**

- 요구사항의 신뢰성 높이고 기술 문제에 대한 위험 감소시키기 위해 별도로 만드는 간단한 프로그램
- 처리할 문제 이외 다른 조건 무시하고 작성

**이터레이션**

- 하나의 릴리즈 더 세분화한 단위, 1~3주
- 기간 중에 새로운 스토리 작성 가능

**승인 검사 (인수 테스트)**

- 하나의 이터레이션 안에서 계획된 릴리즈 단위의 부분 완료 제품이 구현되면 수행하는 테스트
- 사용자 스토리에 기제한 테스트 케이스 고객이 직접 수행
- 오류는 다음 이터레이션에 포함
- 완료되면 다음 이터레이션 시작

**소규모 릴리즈**

- 고객의 반응 기능별로 확인 가능, 요구사항에 좀 더 유연하게 대응 가능
- 릴리즈가 완제품이 아닌 경우 다음 릴리즈 일정에 맞게 개발 계속 진행



### 요구사항 정의

#### 요구사항의 개념 및 특징

- SW가 어떤 문제를 해결하기 위해 제공되는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약 조건 등
- 개발에 참여하는 이행관계자들 간의 의사소통 원활하게 하는데 도움을 준다.
- 제대로 정의 되어야 이를 토대로 이후 과정의 목표와 계획을 수립할 수 있다.

#### 요구사항 유형

**기능 요구사항**

- 시스템이 수행하야 하는 기능 

**비기능 요구사항**

- 장비(HW, SW, 네트워크 등), 성능(속도, 처리량, 등), 인터페이스 등등

**사용자 요구사항**

- 사용자 관점에서 본 시스템이 제공해야 할 요구사항

**시스템 요구사항**

- 개발자 관점에서 본 시스템이 사용자에게 제공해야 할 요구사항

#### 요구사항 개발 프로세스

- 도출 -> 분석 -> 명세 -> 확인





## 애플리케에션 설계

### 소프트웨어 아키텍처

#### 소프트웨어 아키텍처 설계

소프트웨어의 골격이 되는 기본 구조

- 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템 구조 또는 구조체
- 개발 시 적용되는 원칙과 지침, 이해 관계자들의 의사소통 도구로 활용
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정
- 소프트웨어 아키텍처 설계의 기본 원리 : 모듈화, 추상화, 단계적 분해, 정보 은닉



#### 모듈화

소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것

- 모듈 크기가 너무 작으면 개수가 많아짐, 모듈 간의 통합 비용이 많이 듦
- 모듈 크기가 너무 크면 개수가 적어져 통합 비용이 줄어듦, 하지만 모듈 하나의 개발 비용이 많이 듦

#### 추상화

문제의 전체적이고 포관적인 개념 설계한 후 차례로 세분화해 구체화시켜 나가는 것

- 시스템과 유사한 모델 만들어 여러 요인 테스트
- 최소의 비용으로 실제 상황에 대처 가능, 시스템의 구조 및 구성을 대략적으로 파악 가능

| 추상화 유형   | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 과정 추상화   | 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계 |
| 데이터 추상화 | 데이터의 세부적인 속성이나 용도 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체 |
| 제어 추상화   | 이벤트 발생의 정확한 절차나 방법 정의하지 않고, 대표할 수 있는 표현으로 대체 |

#### 단계적 분해

- 하향식 설계 전략
- 문제를 상위 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
- 추상화의 반복에 의해 세분화됨

#### 정보 은닉

한 모듈 내부에 포함된 절차와 자료들의 정보를 감춰 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

- 정보 은닉 모듈과 커뮤니케이션할 필요가 있을 때는 필용한 정보만 인터페이스를 통해 주고 받음
- 수정, 시험, 유지보수가 용이

#### 소프트웨어 아키텍처의 설계 과정

1. 설계 목표 설정

   시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비지니스 목표, 우선순위 등 요구사항을 분석해 전체 시스템의 설계 목표 설정

2. 시스템 타입 결정

   시스템의 타입을 결정하고 설계 목표와 함께 고려해 아키텍처 패턴 선택

3. 아키텍쳐 패턴 적용

   아키텍처 패턴을 참조해 시스템의 표준 아키텍처를 설계

4. 서브시스템 구체화

   서브시스템의 기능 및 서브시스템 간 상호작용을 위한 동작과 인터페이스를 정의함

5. 검토

   아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계의 기본원리를 만족하는지 등 검토

   

### 아키텍처 패턴

#### 아키텍처 패턴 개요

아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

- 장점
  - 개발시간 단축, 고품질 소프트웨어 생산
  - 이해간계자들 간의 의사소통 간편
  - 개발 전에 시스템의 특성 이해 가능
- 종류 : 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴

#### 레이어 패턴

시스템을 계층으로 구분하여 구성하는 방법

- 각각의 서브시스템들이 계층 구조를 이룸
- 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이뤄짐

#### 클라이언트-서버 패턴

하나의 서버 컴포턴트와 다수의 클라이언트 컴포넌트로 구성되는 패턴

- 사용자는 클라이언트와만 의사소통을 함
- 서버는 항상 대기 상태 유지
- 클라이언트-서버는 서로 독립적

#### 파이프-필터 패턴

데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴

- 필터 재사용성, 확장성 용이
- 재배치를 통한 다양한 파이프라인 구축 가능
- 데이터 변환, 버퍼링, 동기화 등에 주로 사용

#### 모델-뷰-컨트롤러 패턴

서브시스템을 3개의 부분으로 구조화하는 패턴

- 모델 : 서브시스템의 핵심 기능과 데이터 보관
- 뷰 : 사용자에게 정보 표시
- 컨트롤러 : 사용자로부터 받은 입력 처리
- 각 컴포넌트 독립적임
- 여러개의 뷰를 필요로 하는 대화형 어플리케이션에 적합





## 객체지향

#### 객체지향 개요

현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때 객체들을 조립해서 작성할 수 있는 기법

- 소프트웨어의 재사용 및 확장이 용이하여 고품질 SW 빠르게 개발, 유지보수 쉬움
- 복잡한 구조를 단계적, 계층적으로 표현
- 멀티미디어 데이터 및 병렬 처리 지원
- 주요 구성 요소 및 개념 : 객체, 클래스, 캡슐화, 상속, 다형성

#### 객체

데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화) 하나의 소프트웨어 모듈

#### 클래스

공통된 속성과 연산(행위)을 갖는 객체의 집합으로 객체의 일반적인 타입

- 클래스에 속한 객체를 인스턴스라고 함
- 최상위 클래스는 상위 클래스를 갖지 않는 클래스를 의미함
- 슈퍼 클래스는 특정 클래스의 상위(부모) 클래스이고, 서브 클래스는 특정 클래스의 하위(자식) 클래스를 의미

#### 캡슐화 

데이터와 함수를 하나로 묶는 것

- 캡슐화된 객체는 인터페이스를 제외한 세부 내용 은폐 => 외부 모듈의 변경으로 인한 파급 효과가 적음
- 재사용 용이, 객체 간 결합도 낮아짐

#### 상속

상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것

- 상속 받은 것 이외에 새로운 속성과 연산 첨가 가능 (오버라이딩)
- 재사용성 높임

#### 다형성

메시지에 의해 객체가 연산을 수행할 때 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력

- 객체들은 동일한 메소드명 사용해 같은 의미의 응답을 함 (오버로딩)



### 모듈

#### 모듈 개요

모듈화를 통해 분리된 시스템의 각 기능들로 서브루틴, 서브 시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용됨

- 하나의 모듈이 하나의 기능만 수행, 다른 모듈과의 과도한 상호작용 지양
- 독립성이 높은 모듈일수록 다른 모듈에게 영향 미치지 않음
- 응집도는 강하게 결합도는 약하게 => 독립성 높아짐

#### 결합도

모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계

#### 응집도

정보 은닉 개념의 확장, 명령어나 호출문 등 모듈의 내부 요소들이 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도 의미



### 애플리케이션 테스트

#### 화이트박스 테스트

모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법

- 설계된 절차에 초점을 둔 구조적 테스트
- 테스트 과정 초기에 적용
- 모듈 안의 작업 직접 관찰
- 프로그램 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어함

#### 블랙박스 테스트

소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트로, 기능 테스트라고도 함

- 사용자의 요구사항 명세를 보면서 테스트하는 것, 주로 구현된 기능을 테스트함
- 테스트 과정 후반에 적용

| **구분** |                     **Black Box Test**                     |                **White Box Test**                |
| :------: | :--------------------------------------------------------: | :----------------------------------------------: |
|   정의   | 모듈사양서를 기초로 입력/출력 조건 등 모든 기능면의 테스트 | 모듈 사양서 소스코드를 기초로 모듈의 논리 테스트 |
|   관점   |                        사용자 관점                         |                   개발자 관점                    |
|   기준   |                  인터페이스 및 성능 오류                   |                   논리상 오류                    |
|   V&V    |                  상위 레벨 (사용자 환경)                   |              하위 레벨 (시험 환경)               |
|   대상   |                 시작/종료/인터페이스 결함                  |         루프, Decision 결함, 비수행 구문         |
|   기법   |                  동등 분할, 경계값분석 등                  |              루프, 제어구조 테스트               |
|   활용   |                        베타 테스트                         |                   알파 테스트                    |